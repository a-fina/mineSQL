/*
 * Generated by the Jasper component of Apache Tomcat
 * Version: Apache Tomcat/7.0.50
 * Generated at: 2015-01-20 09:54:44 UTC
 * Note: The last modified time of this file was set to
 *       the last modified time of the source file after
 *       generation to assist with modification tracking.
 */
package org.apache.jsp.autogrid;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;
import java.util.Date;
import net.mineSQL.connection.ConnectionManager;
import net.mineSQL.controller.MineGrid;
import java.sql.*;
import java.util.*;
import java.io.*;
import javax.servlet.http.HttpServletRequest;
import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import net.sf.json.JSONSerializer;
import org.apache.log4j.Logger;
import net.mineSQL.util.*;
import net.mineSQL.connection.*;
import net.mineSQL.util.Constants;
import net.mineSQL.util.Utilita;
import net.mineSQL.controller.MineScript;
import net.mineSQL.controller.MineTable;
import java.util.Date;
import java.util.regex.*;
import com.j256.ormlite.dao.DaoManager;
import com.j256.ormlite.support.ConnectionSource;
import com.j256.ormlite.jdbc.JdbcConnectionSource;
import com.j256.ormlite.dao.Dao;
import net.mineSQL.model.dao.Report;
import java.util.*;

public final class auto_002djson_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent {


    /* DB settings */
    Connection con = null;

    /* GET/POST parameters */
    String idQuery=null;
    String bodyQuery=null;
    int start = 0;
    int limit = 10;
    String dir = "ASC";
    String sort = "";
    String tableName = "";
    String databaseName = "";
    String hostName = "";
    String pageContext = "";
    String action = "";

    /* Letti dal DB */
    String query=null;
    String querySel=null;
    String nomeQuery=null;

    String DEFAULT_TESTO = "$testo";

    Logger log = Logger.getLogger("auto-json.jsp");
    /*
    * Cattura i parametri postati
    * @param req HttpServletRequest
    */ 
    public void doGet(HttpServletRequest req) throws ConnectionException, SQLException {
        if (req.getParameter("idQuery") != null) idQuery = req.getParameter("idQuery");
        else idQuery = null;
        if (req.getParameter("databaseName") != null) databaseName = req.getParameter("databaseName");
        else databaseName = "mineSQL";
        if (req.getParameter("tableName") != null) tableName = req.getParameter("tableName");
        else tableName = null;
        if (req.getParameter("hostName") != null) hostName = req.getParameter("hostName");
        else hostName = "localhost";
        if (req.getParameter("bodyQuery") != null && ! req.getParameter("bodyQuery").equals("")) 
            bodyQuery = req.getParameter("bodyQuery");
        else bodyQuery = null;
        if (req.getParameter("start") != null) start = (new Integer(req.getParameter("start"))).intValue();
        if (req.getParameter("limit") != null) limit = (new Integer(req.getParameter("limit"))).intValue();
        if (req.getParameter("sort") != null) sort = req.getParameter("sort");
        if (req.getParameter("dir") != null) dir = req.getParameter("dir");
        if (req.getParameter("context") != null) pageContext = req.getParameter("context");
        if (req.getParameter("action") != null) 
            action = req.getParameter("action");
        else action = "dummy";

        log.debug("Try to connecting to: " + hostName +":"+databaseName);
        con = ConnectionManager.getConnection(hostName,databaseName);
    }
    /*
    * Va sul DB e si carica il testo della query da visualizzare nella griglia
    * @param  request
    * @return 
    */ 
    public void getQueryStatement(HttpServletRequest req, String table, String where) throws SQLException{
        if (bodyQuery != null){
            log.info("- - - - > MARK_FILTER bodyQuery: " + bodyQuery );
            query = bodyQuery;
        }else{
            if (where != null)
                where = " WHERE " + where;
			log.debug(" getQueryStatement sqL: " + "select * from "+ table +" "+  where);
            ResultSet rs = doQuery("select * from "+ table +" "+  where);
            while (rs.next()) {
                nomeQuery=rs.getString("nome");
                log.debug("-> MARK_FILTER nome script: CLOB di MERDA XXXX YYY className: " +
                    //rs.getClob("testo").getClass().getName()
                    rs.getString("testo").getClass().getName()
                );
                /*oracle.sql.CLOB value = (oracle.sql.CLOB) rs.getClob("testo");
                query = inputStreamAsString(value);*/
                query = rs.getString("testo");
                querySel = rs.getString("script_out");

                log.debug("-> MARK_FILTER nomeQuery: " + nomeQuery +" testo script:\n " + query); 
            }
            log.info("->  MARK_FILTER query: " + query ); 
        }
    }
    /**
    * Restituisce il numero di righe della query
    * @param query SQL statement
    * @return integer
    */ 
    public int getRowsNumber(String _query) throws SQLException{
        log.debug(" getRowsNumber before executed query: " + _query+ " Con: " + con);
        ResultSet rs = doQuery("select count(*) tot from (" + _query + ") as counteggio");
        rs.next();
        return rs.getInt("TOT");
    }
	/*public String inputStreamAsString(CLOB clob){
		String strValue="";
		
		if (clob != null) {
		    	BufferedReader re = null;
			try {
			    String str;
			    re = new BufferedReader(clob.getCharacterStream());
			    while ((str = re.readLine()) != null) {
			    	strValue += str + '\n';
			    }

			    //strValue = sbuf.toString();
			    if (strValue.length() == 0) strValue = "";
			} catch (SQLException e) {
				log.error("", e);
			} catch (IOException e) {
			    	log.error("", e);
			}
			finally {
			    try {
				re.close();
			    }
			    catch (IOException e) {
				log.error("Chiusura BufferedReader", e);
			    }
			}
		}
		log.debug(">>>>>> inputStreamAsString | strValue: " + strValue);
		return strValue;
	}*/
    /**
    * Prepara lo staement ed esegue la query
    * @param query
    * @return ResultSet
    * @see ResultSet
    */ 
    private ResultSet doQuery(String query) throws SQLException{
        PreparedStatement ps = null;
        ResultSet rs  = null;
        log.debug(" before executed query: " + query+ " Con: " + con);
        ps = con.prepareStatement(query,
                                  ResultSet.TYPE_SCROLL_SENSITIVE,
                                  ResultSet.CONCUR_READ_ONLY);
        log.info(" after executed query: " + query);
        rs = ps.executeQuery();
        return rs;
    }
    /**
    * Scandisce la hashMap e costruisce la stringa della clausula WHERE
    * @param hm hashMap[nome, valore]
    * @return   stringa con la clausula where 
    * @see String
    */      
    public String addWhere(String query, HashMap hm){
        String whereClause = " WHERE ";
	    Iterator it = hm.keySet().iterator();
	    Object key = null;
        while ( it.hasNext()  )  {  
            key = it.next();	
            whereClause += " AAA." +key.toString()+ " LIKE  '" +hm.get(key)+ "' ";
            if ( it.hasNext() )
                whereClause += "AND";
        }
        if (! whereClause.equals(" WHERE "))
            query = "select AAA.* from (" + query + ") as AAA " + whereClause;
        return query;
    }


    /**
    * Aggiunge la paginazione alla query
    * @param query
    * @param start
    * @param linit
    */ 
    public String getPaginationOracle(String query, int start, int limit){
		String sql = "select * " +
					"from (select rownum \"#\", a.* " +
						  "from (" +  query + " ) a " +
						  "where  rownum<=" + (start + limit) + ") " +
					"where \"#\" > " + start + " ";
		log.debug(" getPagination sql: " + sql);
		return sql;
    }
    public String getPaginationDB2(String query, int start, int limit){
        String sql = "select * from ( " +
            "select ROW_NUMBER() OVER() as NUM, a.* from " + 
            "( " + query +" )" + 
            " as a) as b where  b.NUM <=" + (start + limit) + " and NUM >" + start + " ";

		log.debug(" getPaginationDB2 sql: " + sql);
		return sql;
    }
    public String getPaginationMySQL(String query, int start, int limit){
		String sql =  query + " LIMIT "+start+", "+limit;
		log.debug(" getPagination sql: " + sql);
		return sql;
    }
    public String getPagination(String query, int start, int limit){
        return getPaginationDB2(query, start, limit);
    }


    // C'era una volta un Export Excel che poteva leggere solo dalla tabella
    // DM_QUERY_T. Laddove questo  metodo venga chiamato senza specificare la tabella
    // verra presa la buon vecchia DM_QUERY_T.
	public void getFinalQuery(HttpServletRequest request) throws SQLException, ConnectionException {
        getFinalQuery(request, "DM_QUERY_T");
    }

    // Assembla i parametri di POST, e restituisce il testo completo della query
    // paginata e con tutti le condizioni impostate	
	public void getFinalQuery(HttpServletRequest request, String table ) throws SQLException, ConnectionException {
        // Prendo i parametri
        //log.info(" auto-excel.jsp | con" + con);
        doGet(request);
        
        int filterCount = 0;
        
        // Estraggo il testo della query
        getQueryStatement(request, table ,"id="+idQuery);
       
        // Se il ho già il corpo della query esco
        // altrimenti aggiungo le clausole WHERE 
        if (bodyQuery != null)
            return;
        
        // Se è un export di un report allora la variabile query contiene già i valori 
        // dei filtri impostati, mentre se sto esportando delle entità devo prelevare i
        // valori dei filtri direttamente dalle variabili in sessione "filter" e "searchCondition"
        if (pageContext.equals("Problem") || pageContext.equals("Defect") ||
            pageContext.equals("Task") || pageContext.equals("Workaround")) {
            
            if ((request.getSession().getAttribute("filter") != null) &&
                (request.getSession().getAttribute("searchCondition") != null)) {
                String addAnd = " AND ";
                if (request.getSession().getAttribute("searchCondition")=="") addAnd = ""; 
                query = query + " WHERE 1 = 1 " +
                        addAnd + 
                        request.getSession().getAttribute("searchCondition")+ 
                        request.getSession().getAttribute("filter");	
                // log.info("3.1 - logan - - ->getFinalQuery MARK_FILTER query: " +  query );
            }
        }// Aggiungo i filtri contestuali dei Report.
        else if (pageContext.equals("Report")) {
            if ((request.getSession().getAttribute("filter") != null) &&
                (request.getSession().getAttribute("searchCondition") != null)) {
                query = "select * from (" + query + ") WHERE 1=1 " + 
                    request.getSession().getAttribute("filter");
                // log.info("3.2 - logan - - ->getFinalQuery MARK_FILTER query: " +  query );
            }
        }
    }

    // Restituisce una mappa dei valori postati
    // Prende tutte la varibili postate che cominciano
    // con MineTable.prefix;
    private HashMap Post2HashMap(HttpServletRequest request){
        HashMap hm = null;
        return hm;
    }

public static void execScript(Connection conn, String stmt) throws SQLException
{
    PreparedStatement st = null;
    try
    {
       st = conn.prepareStatement(stmt.replaceAll("\r", "\n"));
       //st.executeUpdate();
       st.execute();
    }

    finally
    {
       if (st != null) st.close();
    }
}    
    
public static void execSQL(Connection conn, String stmt) throws SQLException
{
InputStream in = null;

//try {
        // InputStream is = new ByteArrayInputStream(text.stmt("UTF-8"));
//} catch (UnsupportedEncodingException e) {
//            e.printStackTrace();
//}

Scanner s = new Scanner(in);
s.useDelimiter("(;(\r)?\n)|(--\n)");
Statement st = null;
try
{
st = conn.createStatement();
while (s.hasNext())
{
String line = s.next();
if (line.startsWith("/*!") && line.endsWith("*/"))
{
int i = line.indexOf(' ');
line = line.substring(i + 1, line.length() - " */".length());
}

if (line.trim().length() > 0)
{
st.execute(line);
}
}
}
finally
{
if (st != null) st.close();
}
}



  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map<java.lang.String,java.lang.Long> _jspx_dependants;

  static {
    _jspx_dependants = new java.util.HashMap<java.lang.String,java.lang.Long>(2);
    _jspx_dependants.put("/autogrid/../config.jsp", Long.valueOf(1421747451249L));
    _jspx_dependants.put("/autogrid/auto-lib.jsp", Long.valueOf(1415270612256L));
  }

  private javax.el.ExpressionFactory _el_expressionfactory;
  private org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map<java.lang.String,java.lang.Long> getDependants() {
    return _jspx_dependants;
  }

  public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
        throws java.io.IOException, javax.servlet.ServletException {

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      response.setContentType("text/html; charset=ISO-8859-1");
      pageContext = _jspxFactory.getPageContext(this, request, response,
      			null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("  \n");
      out.write("\n");



    String HOST = "HOST";
    String USER = "USER";
    String PASSWORD = "PASSWORD";
    String DATABASE = "DATABASE";
    String SHOW_ALL_DATABASE = "SHOW_ALL_DATABASE";
    String NAME = "NAME";

    HashMap<String, String> confConnection = new HashMap<String, String>();
    List connections = new ArrayList();



    confConnection = new HashMap<String, String>();
    confConnection.put(HOST, "192.168.10.243");
    confConnection.put(USER,"TNFIAL");
    confConnection.put(PASSWORD,"ale20142");
    confConnection.put(SHOW_ALL_DATABASE,"false");
    confConnection.put(DATABASE,"TIESSEFIL");
    confConnection.put(NAME,"local");
    connections.add(confConnection);


    /* Add new connection
    confConnection = new HashMap<String, String>();
    confConnection.put(HOST, "1.1.1.1");
    confConnection.put(USER,"");
    confConnection.put(PASSWORD,"");
    confConnection.put(SHOW_ALL_DATABASE,"false");
    confConnection.put(DATABASE,"");
    confConnection.put(NAME,"local");
    connections.add(confConnection);
    */


      out.write('\n');
      out.write('\n');
      out.write('\n');
      out.write('\n');
      out.write('\n');
      out.write('\n');

    try {

        // Prendo i parametri
        doGet(request);

        // JSON Completo
        JSONObject griglia = new JSONObject();
        Date before = new Date();

        log.info("Connected to: " + hostName + ":" + databaseName);

        // Applico il filtro la query
        String filter = Utilita.getFilterCondition(con, request, "", "", "");
        //TODO: questa pagina auto-json.jsp viene richiamata sia quando si submita la form
        //      con i parmaetri dello script, sia quando si mettono i filtri sulla griglia. 
        MineScript script = new MineScript();
        MineTable table = new MineTable(con, tableName);

        PreparedStatement ps = null;
        ResultSet rs = null;
        int rowCounter = 10;

        log.debug(" MARK_ENTRY database:" + databaseName + " tablename:" + tableName + " action: " + action);
        if ((/* tableName.equals("msq_SCRIPT_T")  &&*/action.equals("runQuery"))
                || action.equals("runDefaultScript") || action.equals("runSavedScript") || action.equals("runScript")) {

            // Se submit dalla FORM eseguo lo SCRIPT e successivamente eseguo lo SCRIPT_OUTPUT
            if (action.equals("runScript") || action.equals("saveScript")) {
                /**
                 * **************
                 * log.debug(" tableName.equals(\"msq_SCRIPT_T\") &&
                 * action.equals(\"dummy\") idQuery: " + idQuery); // Preparo la
                 * query con Paginazione getQueryStatement(request, tableName,
                 * where);
                 *
                 * log.debug("- - - - > MAR_OLD_QUERY: " + query ); query =
                 * script.mergeScriptParameters(table.getSubmittedParams(request),
                 * query); log.debug("- - - - > MAR_NEW_QUERY: " + query );
                 * ********
                 */
                HashMap formParams = table.getSubmittedParams(request);
                query = script.mergeScriptParameters(formParams, DEFAULT_TESTO);  // testo e' la textarea di default
                log.debug(" MARK_runScript query: " + query + " params: " + formParams + " querySel: " + querySel);
                //Definito in auto-lib.jsp, non produce output ed seguo lo SCRIPT riga per riga
                execScript(con, query);

                Date after = new Date();
                long diff = after.getTime() - before.getTime();

                log.info(" Run script : " + query);
                log.info(" Execution time: " + diff + "ms");
                griglia.put("Script", "Successfully finished in " + diff + "ms");
            } else if (action.equals("runQuery")) {

                // quando si ricarica solo la griglia, lo SCRIPT non viene piu eseguito ma
                // si eseguo solo SCRIPT_OUTPUT che ricarica i dati della griglia
                // Creare sul DB una nova tabella in cui mettere delle query che estraggono
                // solo i dati di l'output. 
                // Serve per forza un query di estrazione perché le colonne della griglia
                // devono essere cablate in qualche modo
                // TODO modificare Autogrid.js in modo da diversificare il nome di tableName
                // con i parametri di POST
                // Testo libero TODO
                Connection conForsavedScript = ConnectionManager.getConnection("localhost", "mineSQL");
                MineTable runQuery = new MineTable(conForsavedScript, "msq_SCRIPT_T");
                log.debug(" MARK_runQuery query database:" + databaseName + " tablename:" + tableName + " idQuery: ");
                query = runQuery.select("testo", "ID = '" + idQuery + "'");

                HashMap formParams = table.getSubmittedParams(request);
                log.debug(" MARK_runQuery 1 query: " + query + " params: " + formParams + " querySel: " + querySel);
                query = script.mergeScriptParameters(formParams, query);  // testo e' la textarea di default
                log.debug(" MARK_runQuery 2 query: " + query + " params: " + formParams + " querySel: " + querySel);

            } else if (action.equals("runDefaultScript")) {
                // Preparo la query con Paginazione
                String db_table = databaseName + "." + tableName;
                query = "SELECT * FROM " + db_table + " WHERE 1=1";
                //getQueryStatement(request,tableName, where);
                log.debug(" MARK_runDefaultScriptquery database:" + databaseName + " tablename:" + tableName);
                //TODO gestire la query a test libero, viene postata la variabuile query_body
            } else if (action.equals("runSavedScript")) {
/******
                Connection conForsavedScript = ConnectionManager.getConnection("localhost", "mineSQL");
                MineTable savedScript = new MineTable(conForsavedScript, "msq_FILTRI_T");
                log.debug(" MARK_runSavedScript 3 database:" + databaseName + " tablename:" + tableName + " idQuery: ");
                query = savedScript.select("DESCRIZIONE", "ID = '" + idQuery + "'");
    **************/
                /*
                 * TODO: qui volendo si puo mettere un controllo incrociato su databaseName + hostname
                 * e i valori salvati nel DB insieme al testo 
                 */
                Dao<Report, Integer> reportDao;
                String path = "Z:/Finamore/";
                String dbName = "minesql_report";
                String DATABASE_URL = "jdbc:h2:file:" + path + dbName;

                ConnectionSource connectionSource = new JdbcConnectionSource(DATABASE_URL);
                reportDao = DaoManager.createDao(connectionSource, Report.class);
                query = reportDao.queryForId(new Integer(idQuery).intValue()).getDescrizione();
                log.debug(" MARK_runSavedScript database query:" + query);

                if (connectionSource != null) {
                    connectionSource.close();
                }

            }
            // Costruzione query coni filri utente
            if (filter.length() > 0) {
                query = "select FILT_AUX.* from (" + query + ") as FILT_AUX WHERE 1=1 " + filter;
                request.getSession().setAttribute("filter", filter);
                request.getSession().setAttribute("searchCondition", "");
                log.info("3 - - - ->getQueryStatement MARK_FILTER query: " + query);
            } else {
                request.getSession().removeAttribute("searchCondition");
                request.getSession().removeAttribute("filter");
                log.info("3.1 - - - ->getQueryStatement MARK_FILTER query reset filter: " + query);
            }

            // TODO qui si può salvare la query con i FILTRI 
            if (action.equals("saveScript")) {

                String path = "Z:/Finamore/";
                String dbName = "minesql_report";
                String DATABASE_URL = "jdbc:h2:file:" + path + dbName;
                Dao<Report, Integer> reportDao;
                ConnectionSource connectionSource = new JdbcConnectionSource(DATABASE_URL);

                reportDao = DaoManager.createDao(connectionSource, Report.class);

                Report repo = new Report(request.getParameter("NOME"), request.getParameter("NOTE"));
                repo.setDescrizione(query);
                repo.setHost(hostName);
                repo.setDatabase(databaseName);
                repo.setUtente("0");
                reportDao.create(repo);

                int res = reportDao.create(repo);
                if (connectionSource != null) {
                    connectionSource.close();
                }
            }

            // Paginazione
            rowCounter = getRowsNumber(query);
            query = getPagination(query, start, limit);
            log.debug("4.2 query paginata MARK_FILTER : " + query);

            // Eseguo effettivamente la query
            log.debug(query);
            ps = con.prepareStatement(query, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);
            rs = ps.executeQuery();
            Date after = new Date();
            long diff = after.getTime() - before.getTime();

            ResultSetMetaData rsMd = rs.getMetaData();
            int numberOfColumns = rsMd.getColumnCount();

            log.info(" Run report query : " + query);
            log.info(" Execution time: " + diff + "ms");
            rs.last();
            int countRow = rs.getRow();
            rs.beforeFirst();

            //TODO Crere un nuovo constructor in MineGrid.java che prende in input
            // il testo della query già completa di filtri vari
            // Colonne
            if (request.getParameter("column") != null) {
                //TODO qui si puo richiamare MineGrid.java -> jsonColumeModel() 
                JSONArray array_colo = new JSONArray();
                for (int i = 1; i <= numberOfColumns; i++) {
                    JSONObject colonna = new JSONObject();
                    String valore = rsMd.getColumnLabel(i);
                    colonna.put("id", valore);
                    colonna.put("header", valore);
                    colonna.put("dataIndex", valore);

                    if (valore.equals("IDTASK")) {
                        colonna.put("renderer", "renderTask");
                    }
                    if (!valore.equals("#")) {
                        array_colo.add(colonna);
                    }
                } // return array_colo
                griglia.put("column", array_colo);
            }

            // Fields
            if (request.getParameter("meta") != null) {
                //TODO qui si puo richiamare MineGrid.java -> jsonResultSet() 
                JSONObject metaData = new JSONObject();
                JSONArray array_colo = new JSONArray();
                for (int i = 1; i <= numberOfColumns; i++) {
                    JSONObject colonna = new JSONObject();
                    colonna.put("name", rsMd.getColumnLabel(i));
                    if (!colonna.equals("#")) {
                        array_colo.add(colonna);
                    }
                }
                metaData.put("totalProperty", "results");
                metaData.put("root", "rows");
                //metaData.put("id",rsMd.getColumnLabel(1));
                metaData.put("fields", array_colo); // return metaData
                griglia.put("metaData", metaData);
            }
            // Rows
            if (request.getParameter("data") != null) {
                griglia.put("results", "" + rowCounter);

                MineGrid jsonGrid = new MineGrid(rs);
                boolean render = true;
                griglia.put("rows", jsonGrid.getJSON(render));
            }

            // JSON output
            out.print(griglia);
            rs.close();
            ps.close();
        }

    } catch (SQLException sqle) {
        JSONObject error = new JSONObject();
        // Loop through the SQL Exceptions TODO portare nel compending e idea
        error.put("error", sqle + "<br/> Controllare la query: " + query);
        while (sqle != null) {
            log.error("State  : " + sqle.getSQLState());
            log.error("Message: " + sqle.getMessage());
            log.error("Error  : " + sqle.getErrorCode());

            sqle = sqle.getNextException();
        }
        out.print(error);
    } finally {
        try {
            con.close();
        } catch (Exception ex) {
            JSONObject error = new JSONObject();
            error.put("error", ex.toString());
            out.print(error);
        }
    }

      out.write('\n');
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null && out.getBufferSize() != 0)
          try { out.clearBuffer(); } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}
