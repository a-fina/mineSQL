/*
 * Generated by the Jasper component of Apache Tomcat
 * Version: Apache Tomcat/7.0.50
 * Generated at: 2015-01-20 09:52:09 UTC
 * Note: The last modified time of this file was set to
 *       the last modified time of the source file after
 *       generation to assist with modification tracking.
 */
package org.apache.jsp.menus;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;
import net.mineSQL.connection.*;
import java.util.*;
import java.sql.*;
import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import org.apache.log4j.Logger;
import java.sql.*;
import java.util.*;
import java.io.*;
import javax.servlet.http.HttpServletRequest;
import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import net.sf.json.JSONSerializer;
import org.apache.log4j.Logger;
import net.mineSQL.util.*;
import net.mineSQL.connection.*;
import net.mineSQL.util.Constants;
import net.mineSQL.util.Utilita;
import net.mineSQL.controller.MineScript;
import net.mineSQL.controller.MineTable;
import java.util.Date;
import java.util.regex.*;
import com.j256.ormlite.dao.DaoManager;
import com.j256.ormlite.support.ConnectionSource;
import com.j256.ormlite.jdbc.JdbcConnectionSource;
import com.j256.ormlite.dao.Dao;
import net.mineSQL.model.dao.Report;
import java.util.*;

public final class databases_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent {


    /* DB settings */
    Connection con = null;

    /* GET/POST parameters */
    String idQuery=null;
    String bodyQuery=null;
    int start = 0;
    int limit = 10;
    String dir = "ASC";
    String sort = "";
    String tableName = "";
    String databaseName = "";
    String hostName = "";
    String pageContext = "";
    String action = "";

    /* Letti dal DB */
    String query=null;
    String querySel=null;
    String nomeQuery=null;

    String DEFAULT_TESTO = "$testo";

    Logger log = Logger.getLogger("auto-json.jsp");
    /*
    * Cattura i parametri postati
    * @param req HttpServletRequest
    */ 
    public void doGet(HttpServletRequest req) throws ConnectionException, SQLException {
        if (req.getParameter("idQuery") != null) idQuery = req.getParameter("idQuery");
        else idQuery = null;
        if (req.getParameter("databaseName") != null) databaseName = req.getParameter("databaseName");
        else databaseName = "mineSQL";
        if (req.getParameter("tableName") != null) tableName = req.getParameter("tableName");
        else tableName = null;
        if (req.getParameter("hostName") != null) hostName = req.getParameter("hostName");
        else hostName = "localhost";
        if (req.getParameter("bodyQuery") != null && ! req.getParameter("bodyQuery").equals("")) 
            bodyQuery = req.getParameter("bodyQuery");
        else bodyQuery = null;
        if (req.getParameter("start") != null) start = (new Integer(req.getParameter("start"))).intValue();
        if (req.getParameter("limit") != null) limit = (new Integer(req.getParameter("limit"))).intValue();
        if (req.getParameter("sort") != null) sort = req.getParameter("sort");
        if (req.getParameter("dir") != null) dir = req.getParameter("dir");
        if (req.getParameter("context") != null) pageContext = req.getParameter("context");
        if (req.getParameter("action") != null) 
            action = req.getParameter("action");
        else action = "dummy";

        log.debug("Try to connecting to: " + hostName +":"+databaseName);
        con = ConnectionManager.getConnection(hostName,databaseName);
    }
    /*
    * Va sul DB e si carica il testo della query da visualizzare nella griglia
    * @param  request
    * @return 
    */ 
    public void getQueryStatement(HttpServletRequest req, String table, String where) throws SQLException{
        if (bodyQuery != null){
            log.info("- - - - > MARK_FILTER bodyQuery: " + bodyQuery );
            query = bodyQuery;
        }else{
            if (where != null)
                where = " WHERE " + where;
			log.debug(" getQueryStatement sqL: " + "select * from "+ table +" "+  where);
            ResultSet rs = doQuery("select * from "+ table +" "+  where);
            while (rs.next()) {
                nomeQuery=rs.getString("nome");
                log.debug("-> MARK_FILTER nome script: CLOB di MERDA XXXX YYY className: " +
                    //rs.getClob("testo").getClass().getName()
                    rs.getString("testo").getClass().getName()
                );
                /*oracle.sql.CLOB value = (oracle.sql.CLOB) rs.getClob("testo");
                query = inputStreamAsString(value);*/
                query = rs.getString("testo");
                querySel = rs.getString("script_out");

                log.debug("-> MARK_FILTER nomeQuery: " + nomeQuery +" testo script:\n " + query); 
            }
            log.info("->  MARK_FILTER query: " + query ); 
        }
    }
    /**
    * Restituisce il numero di righe della query
    * @param query SQL statement
    * @return integer
    */ 
    public int getRowsNumber(String _query) throws SQLException{
        log.debug(" getRowsNumber before executed query: " + _query+ " Con: " + con);
        ResultSet rs = doQuery("select count(*) tot from (" + _query + ") as counteggio");
        rs.next();
        return rs.getInt("TOT");
    }
	/*public String inputStreamAsString(CLOB clob){
		String strValue="";
		
		if (clob != null) {
		    	BufferedReader re = null;
			try {
			    String str;
			    re = new BufferedReader(clob.getCharacterStream());
			    while ((str = re.readLine()) != null) {
			    	strValue += str + '\n';
			    }

			    //strValue = sbuf.toString();
			    if (strValue.length() == 0) strValue = "";
			} catch (SQLException e) {
				log.error("", e);
			} catch (IOException e) {
			    	log.error("", e);
			}
			finally {
			    try {
				re.close();
			    }
			    catch (IOException e) {
				log.error("Chiusura BufferedReader", e);
			    }
			}
		}
		log.debug(">>>>>> inputStreamAsString | strValue: " + strValue);
		return strValue;
	}*/
    /**
    * Prepara lo staement ed esegue la query
    * @param query
    * @return ResultSet
    * @see ResultSet
    */ 
    private ResultSet doQuery(String query) throws SQLException{
        PreparedStatement ps = null;
        ResultSet rs  = null;
        log.debug(" before executed query: " + query+ " Con: " + con);
        ps = con.prepareStatement(query,
                                  ResultSet.TYPE_SCROLL_SENSITIVE,
                                  ResultSet.CONCUR_READ_ONLY);
        log.info(" after executed query: " + query);
        rs = ps.executeQuery();
        return rs;
    }
    /**
    * Scandisce la hashMap e costruisce la stringa della clausula WHERE
    * @param hm hashMap[nome, valore]
    * @return   stringa con la clausula where 
    * @see String
    */      
    public String addWhere(String query, HashMap hm){
        String whereClause = " WHERE ";
	    Iterator it = hm.keySet().iterator();
	    Object key = null;
        while ( it.hasNext()  )  {  
            key = it.next();	
            whereClause += " AAA." +key.toString()+ " LIKE  '" +hm.get(key)+ "' ";
            if ( it.hasNext() )
                whereClause += "AND";
        }
        if (! whereClause.equals(" WHERE "))
            query = "select AAA.* from (" + query + ") as AAA " + whereClause;
        return query;
    }


    /**
    * Aggiunge la paginazione alla query
    * @param query
    * @param start
    * @param linit
    */ 
    public String getPaginationOracle(String query, int start, int limit){
		String sql = "select * " +
					"from (select rownum \"#\", a.* " +
						  "from (" +  query + " ) a " +
						  "where  rownum<=" + (start + limit) + ") " +
					"where \"#\" > " + start + " ";
		log.debug(" getPagination sql: " + sql);
		return sql;
    }
    public String getPaginationDB2(String query, int start, int limit){
        String sql = "select * from ( " +
            "select ROW_NUMBER() OVER() as NUM, a.* from " + 
            "( " + query +" )" + 
            " as a) as b where  b.NUM <=" + (start + limit) + " and NUM >" + start + " ";

		log.debug(" getPaginationDB2 sql: " + sql);
		return sql;
    }
    public String getPaginationMySQL(String query, int start, int limit){
		String sql =  query + " LIMIT "+start+", "+limit;
		log.debug(" getPagination sql: " + sql);
		return sql;
    }
    public String getPagination(String query, int start, int limit){
        return getPaginationDB2(query, start, limit);
    }


    // C'era una volta un Export Excel che poteva leggere solo dalla tabella
    // DM_QUERY_T. Laddove questo  metodo venga chiamato senza specificare la tabella
    // verra presa la buon vecchia DM_QUERY_T.
	public void getFinalQuery(HttpServletRequest request) throws SQLException, ConnectionException {
        getFinalQuery(request, "DM_QUERY_T");
    }

    // Assembla i parametri di POST, e restituisce il testo completo della query
    // paginata e con tutti le condizioni impostate	
	public void getFinalQuery(HttpServletRequest request, String table ) throws SQLException, ConnectionException {
        // Prendo i parametri
        //log.info(" auto-excel.jsp | con" + con);
        doGet(request);
        
        int filterCount = 0;
        
        // Estraggo il testo della query
        getQueryStatement(request, table ,"id="+idQuery);
       
        // Se il ho già il corpo della query esco
        // altrimenti aggiungo le clausole WHERE 
        if (bodyQuery != null)
            return;
        
        // Se è un export di un report allora la variabile query contiene già i valori 
        // dei filtri impostati, mentre se sto esportando delle entità devo prelevare i
        // valori dei filtri direttamente dalle variabili in sessione "filter" e "searchCondition"
        if (pageContext.equals("Problem") || pageContext.equals("Defect") ||
            pageContext.equals("Task") || pageContext.equals("Workaround")) {
            
            if ((request.getSession().getAttribute("filter") != null) &&
                (request.getSession().getAttribute("searchCondition") != null)) {
                String addAnd = " AND ";
                if (request.getSession().getAttribute("searchCondition")=="") addAnd = ""; 
                query = query + " WHERE 1 = 1 " +
                        addAnd + 
                        request.getSession().getAttribute("searchCondition")+ 
                        request.getSession().getAttribute("filter");	
                // log.info("3.1 - logan - - ->getFinalQuery MARK_FILTER query: " +  query );
            }
        }// Aggiungo i filtri contestuali dei Report.
        else if (pageContext.equals("Report")) {
            if ((request.getSession().getAttribute("filter") != null) &&
                (request.getSession().getAttribute("searchCondition") != null)) {
                query = "select * from (" + query + ") WHERE 1=1 " + 
                    request.getSession().getAttribute("filter");
                // log.info("3.2 - logan - - ->getFinalQuery MARK_FILTER query: " +  query );
            }
        }
    }

    // Restituisce una mappa dei valori postati
    // Prende tutte la varibili postate che cominciano
    // con MineTable.prefix;
    private HashMap Post2HashMap(HttpServletRequest request){
        HashMap hm = null;
        return hm;
    }

public static void execScript(Connection conn, String stmt) throws SQLException
{
    PreparedStatement st = null;
    try
    {
       st = conn.prepareStatement(stmt.replaceAll("\r", "\n"));
       //st.executeUpdate();
       st.execute();
    }

    finally
    {
       if (st != null) st.close();
    }
}    
    
public static void execSQL(Connection conn, String stmt) throws SQLException
{
InputStream in = null;

//try {
        // InputStream is = new ByteArrayInputStream(text.stmt("UTF-8"));
//} catch (UnsupportedEncodingException e) {
//            e.printStackTrace();
//}

Scanner s = new Scanner(in);
s.useDelimiter("(;(\r)?\n)|(--\n)");
Statement st = null;
try
{
st = conn.createStatement();
while (s.hasNext())
{
String line = s.next();
if (line.startsWith("/*!") && line.endsWith("*/"))
{
int i = line.indexOf(' ');
line = line.substring(i + 1, line.length() - " */".length());
}

if (line.trim().length() > 0)
{
st.execute(line);
}
}
}
finally
{
if (st != null) st.close();
}
}






//Logger log = Logger.getLogger("filtri.jsp");

/***** Fattorizzare 
class MainMenu {
    String query = "";
    public MainMenu(){
    } 

    public getTreeMenu(){
        return JSONArray mioMenu;
    }
    
}

MainMenu factoryTree = new MainMenu();
JSONArray myTree = factoryTree.getTreeMenu();

class SubMenu {
}
**********/

/**
 * Check if current user role is autorized for the menu
 * @param String roles "1,2,3,4,5,...".
 * @param String user "1,2,3,4,5,...".
 * @return true o false
 */
private boolean isAutorized( String roles, String user)
{
   		boolean autorized = false;	

        if (roles == null) roles = "";

        String[] ro = roles.split(",");

        for (int i = 0 ; i < ro.length ; i++)
            if ( ro[i].equals( user) )
                autorized = true;

        return autorized; 
}

/**
 * Costruisce un nodo del sottoMenu
 */
private JSONObject getSubMenuItem(String id, String title, String text)
{
    return getSubMenuItem(id, title, text, "false");
}
/**
 * Costruisce un nodo del sottoMenu
 */
private JSONObject getSubMenuItem(String id, String title, String text, String disabled)
{
    JSONObject sub = new JSONObject();
    sub.put("text",text);
    sub.put("id",id);
    sub.put("title",title);
    sub.put("cls","file");
    sub.put("iconCls","none");
    sub.put("leaf","false");
    sub.put("disabled",disabled);

    return sub;
}

/**
 * Costruisce un nodo del mainMenu
 */
private JSONObject getMenuItem(String text, JSONArray children, String id)
{
    return getMenuItem(text, children, id, "false");
}
/**
 * Costruisce un nodo del mainMenu
 */
private JSONObject getMenuItem(String text, JSONArray children, String id, String disabled)
{
    JSONObject menu = new JSONObject();
    menu.put("text",text);
    menu.put("expanded","false");
    menu.put("iconCls","none");
    menu.put("disabled",disabled);

    if (id != null )
        menu.put("id",id);
    if (children != null )
        menu.put("children",children);

    return menu;
}

/**
 * Torna il sottomenu specificato nel parametro path a partire 
 * dalla root del menu.
 * Il path ha un formato del tipo /Menu liv 1/Menu liv 2/...
 */
private JSONArray getSubMenu(JSONArray menu, String path) {
    JSONArray currentMenu = menu;
    JSONObject currentNode = null;

    String[] nodes = path.replaceAll("//*/", "/").split("/");
    // Se il path e' vuoto esco subito
    if (path.length() == 0 || nodes.length == 0)
       return currentMenu;

    int liv = 1;
    if (currentMenu.isEmpty())
       // Se il menu e' vuoto, inutile fare ricerche, aggiungo 
       // il nodo di primo livello indicato nel path
       currentMenu.add(getMenuItem(nodes[liv] + "&nbsp;&nbsp;&nbsp;&nbsp;", new JSONArray(), null));

    // Ciclo di ricerca che effettua il best matching del path ricercato
    // nella struttura di menu esistente, scendendo uno alla volta i livelli
    // di menu partendo dal primo.
    boolean isMatching = true;
    while (isMatching && liv < nodes.length) {
       int itemProgr = 0;
       boolean found = false;
       if (currentMenu != null) {
           // Se il sottomenu corrente non e' vuoto si scorrono gli items
           // per verificare l'esistenza del nodo di livello LIV indicato nel path
           while (!found && itemProgr < currentMenu.size()) {
               currentNode = (JSONObject)currentMenu.get(itemProgr);
               String node = (String)currentNode.get("text");
               if (node.equals(nodes[liv] + "&nbsp;&nbsp;&nbsp;&nbsp;"))
                   found = true;
               itemProgr++;
           }
       }
       if (!found) {
	       // Se non viene trovato il nodo di livello LIV indicato nel path
	       // bisogna interrompere il ciclo di ricerca, inutile scendere di livello
           isMatching = false;
       }
       else {
	       // Se viene trovato il nodo di livello LIV indicato nel path,
	       // si passa a considerare il sottomenu di livello LIV + 1
           currentMenu = (JSONArray)currentNode.get("children");
           liv++;
       }
    }

    // Il best-matching ha verificato l'esistenza della struttura menu fino a
    // livello LIV. Si passa a creare i livelli di profondita' maggiore mancanti.
    for (int i = liv; i < nodes.length; i++) {
       currentMenu.add(getMenuItem(nodes[i] + "&nbsp;&nbsp;&nbsp;&nbsp;", new JSONArray(), null));
       currentNode = (JSONObject)currentMenu.get(currentMenu.size() - 1);
       currentMenu = (JSONArray)currentNode.get("children");
    }

    return currentMenu;
}

/*
 * Costruisce un nodo del main menu realtivo ad una connession
 */
private JSONArray getConnectionDBMenu(JSONArray connectionDBmenu, String host, String database, String user, String password, String showAllDB) throws ConnectionException{

            List menuItems = new ArrayList();
            Connection dbCon = null;
            PreparedStatement ps = null;
            ResultSet rs = null;
            ResultSet rs2 = null;

            
            try {
                dbCon = ConnectionManager.getConnection(host, database, user, password);

                // Elenco dei database
                String sqlSCHEMA = "select TABLE_SCHEM as SCHEMA from SYSIBM.SQLSCHEMAS";
                //MySQL: SHOW DATABASES
                if (!Boolean.parseBoolean(showAllDB)) {
                    //MySQL where = " like '" + database+"'" ;
                    //DB2
                    sqlSCHEMA += " where TABLE_SCHEM like '" + database +"'";
                }

                ps = dbCon.prepareStatement(sqlSCHEMA);
                log.debug("Database DB2 menu: " + sqlSCHEMA );
                //ResultSet.TYPE_SCROLL_SENSITIVE,
                //ResultSet.CONCUR_READ_ONLY);
                rs = ps.executeQuery();

                // Mappo tutti i menuItems
                String title = "";
                String tip = "";
                int idRow = 0;
                List savedTable = new ArrayList();

                while (rs.next()) {

                    HashMap anagraf_map = new HashMap();
                    anagraf_map.put("id", "idRow" + idRow);
                    log.debug(" row: " + rs.toString());
                    //Gli spazi &nbsp; servono per fissare un Bug di CSS di firefox
                    title = rs.getString(1) + "&nbsp;&nbsp;&nbsp;&nbsp;";
                    tip = "descrizione riga" + idRow;
                    title = "<span ext:qtip=\"" + tip + "\">" + title + "</span>";

                    anagraf_map.put("nome", title);
                    menuItems.add(anagraf_map);
                    savedTable.add(rs.getString(1));
                    idRow++;
                }
                rs.close();
                ps.close();

                // Scandisco i menuItems e prendo le queries
                Iterator iter = menuItems.iterator();
                Iterator tablesIter = savedTable.iterator();

                // Ciclo di costruzione menu principale, cicla sull'elenco DB
                while (iter.hasNext()) {
                    HashMap anagraf_map = new HashMap();
                    anagraf_map = (HashMap) iter.next();

                    String currentDB = (String) tablesIter.next();

                    //MySQL String sqlTABLE = "show tables from `" + currentDB +"`";
                    String sqlTABLE = "select TABLE_NAME, TABLE_TEXT  from SYSIBM.SQLTABLES where TABLE_SCHEM = '"
                                      + currentDB + "'";
                    // MySQL String sql = "show tables from `" + currentDB +"`";

                    //if (currentDB.contains("-"));
                    //    continue;

                    log.debug(" currentDB 1: " + currentDB);


                    ps = dbCon.prepareStatement(sqlTABLE, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);
                    rs = ps.executeQuery();

                    log.debug(" currentDB 2: " + currentDB);
                    JSONArray gruppo_menu = new JSONArray();
                    String text = "";
                    // Ciclo di costruzione sottoMenu, per ogni tabella fa elenco dei campi
                    int idUniq = 0;
                    String id = "";
                    String text2 = "";
                    String textTip = "";

                    while (rs.next()) {
                        String tableName = rs.getString("TABLE_NAME");
                        // Attacco elenco dei campi del database
                        id = idUniq + "##" + currentDB + "##" + tableName+"##"+host;
                        //MySQL text2 = rs.getString("Tables_in_" + currentDB);
                        textTip = "<span ext:qtip=\""+ rs.getString("TABLE_TEXT") +"\">" + tableName + "</span>";
                        gruppo_menu.add(getSubMenuItem(id, tableName, textTip));
                        //log.debug(" gruppo_menu=" + getMenuItem(text2, date_grafico, null) );
                        idUniq++;
                    }
                    rs.close();
                    ps.close();

                    // Attacco elenco dei databases
                    if (gruppo_menu.size() > 0) {
                        text = anagraf_map.get("nome").toString();
                        connectionDBmenu.add( getMenuItem(text, gruppo_menu, null));
                    }

                    log.debug(" currentDB 3: " + currentDB);
                }
            } catch (SQLException sqle) {
                switch (sqle.getErrorCode()) {
                    default:
                        log.debug("", sqle);
                        break;
                }
            } finally {
                try {
                    dbCon.close();
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
            }


            return connectionDBmenu;
        }



public JSONArray getFiltersListOLDSQL(String entity, String idUtente) throws SQLException {
        // Database init
        PreparedStatement ps = null;
        ResultSet rs = null;

        ps = con.prepareStatement("select * from msq_FILTRI_T where idutente = " + idUtente /*+ " AND IDFLUSSO = " + entity*/ );
        rs = ps.executeQuery();
        log.info(" -----------------> getFiltersList  select * from msq_FILTRI_T where idutente = " + idUtente /*+ " AND IDFLUSSO = " + entity */ );
        JSONArray elenco_filtri = new JSONArray();

        // Ciclo di costruzione sottoMenu, elenco delle queries associate ad ogni reparto
        while (rs.next()) {
            //if ( isAutorized( rs.getString("IDRUOLO"), session.getAttribute("IDRUOLO").toString()  ) ) {
                // Costruzione singolo elemento del sottoMenu
                String id = rs.getString("ID") 
                    + "##" + rs.getString("DATABASE")
                    + "##" + "non_serve"
                    + "##" + rs.getString("HOST");

                String title = rs.getString("NOME"); //filtri_map.get("nome") + " - " + rs.getString("NOME");
                
                String tooltip = rs.getString("NOTE");
                if (rs.wasNull())
                    tooltip = "";
                String text = "<span ext:qtip=\"" + tooltip + "\">"+ title + "</span>";

                elenco_filtri.add( getSubMenuItem(id,title,text) );
            //}
        }

        rs.close();
        ps.close();
    return elenco_filtri;
}

/**
 * Esegue la query e restituisce l'elenco dei grafi TODO: per utente
 */
public JSONArray getGraphList(String userGroup) throws SQLException {
        // Database init
        PreparedStatement ps = null;
        ResultSet rs = null;


        /* String sqlChartMenu = " select sto.idgrafico, ana.nome, ana.descrizione, ana.titolo, " +
                     " tip.nome as tipo, sto.data_elaborazione " +
                     " from dm_stat_anagrafica_grafici_t ana, dm_stat_grafici_t sto, "+
                     " dm_gruppo_t gro, dm_stat_anagr_grafici_gruppo_r gra, " + 
                     " dm_stat_anagr_grafici_gruppo_r gra, " + 
                     " dm_stat_tipi_grafici_t tip " +
                     " where ana.idanagrafica =  sto.idanagrafica and " +
                     " ana.idanagrafica = gra.idanagrafica and " + 
                     " ana.idtipo = tip.idtipo "; // and
                     " gro.idgruppo = gra.idgruppo and gro.nome like '" + userGroup + "'";
                   */
        String sqlChartMenu =
        " select sto.idgrafico, ana.nome, ana.descrizione, ana.titolo,  tip.nome as tipo, sto.data_elaborazione  "+
        " from dm_stat_anagrafica_grafici_t ana, dm_stat_grafici_t sto,    dm_stat_tipi_grafici_t tip  "+ 
        " where ana.idanagrafica =  sto.idanagrafica  and  ana.idtipo = tip.idtipo ";

        log.debug(" sqlChartMenu: " + sqlChartMenu );

        ps = con.prepareStatement(sqlChartMenu);
        rs = ps.executeQuery();
        JSONArray elenco_filtri = new JSONArray();

        // Ciclo di costruzione sottoMenu, elenco delle queries associate ad ogni reparto
        while (rs.next()) {
            //if ( isAutorized( rs.getString("IDRUOLO"), session.getAttribute("IDRUOLO").toString()  ) ) {
                // Costruzione singolo elemento del sottoMenu
                String id = rs.getString("IDGRAFICO") + "##" + rs.getString("TIPO");
                String title = rs.getString("NOME"); //filtri_map.get("nome") + " - " + rs.getString("NOME");
                String tooltip = rs.getString("DESCRIZIONE") + " - " + rs.getString("DATA_ELABORAZIONE");
                if (rs.wasNull())
                    tooltip = "";
                String text = "<span ext:qtip=\"" + tooltip + "\">"+ title + "</span>";

                elenco_filtri.add( getSubMenuItem(id,title,text) );
            //}
        }

        rs.close();
        ps.close();
    return elenco_filtri;
}

  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map<java.lang.String,java.lang.Long> _jspx_dependants;

  static {
    _jspx_dependants = new java.util.HashMap<java.lang.String,java.lang.Long>(3);
    _jspx_dependants.put("/menus/../autogrid/auto-lib.jsp", Long.valueOf(1415270612256L));
    _jspx_dependants.put("/menus/menu-lib.jsp", Long.valueOf(1412775734028L));
    _jspx_dependants.put("/menus/../autogrid/../config.jsp", Long.valueOf(1421747451249L));
  }

  private javax.el.ExpressionFactory _el_expressionfactory;
  private org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map<java.lang.String,java.lang.Long> getDependants() {
    return _jspx_dependants;
  }

  public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
        throws java.io.IOException, javax.servlet.ServletException {

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      response.setContentType("text/html; charset=ISO-8859-1");
      pageContext = _jspxFactory.getPageContext(this, request, response,
      			null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write('\n');
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("\n");
      out.write("  \n");
      out.write("\n");



    String HOST = "HOST";
    String USER = "USER";
    String PASSWORD = "PASSWORD";
    String DATABASE = "DATABASE";
    String SHOW_ALL_DATABASE = "SHOW_ALL_DATABASE";
    String NAME = "NAME";

    HashMap<String, String> confConnection = new HashMap<String, String>();
    List connections = new ArrayList();



    confConnection = new HashMap<String, String>();
    confConnection.put(HOST, "192.168.10.243");
    confConnection.put(USER,"TNFIAL");
    confConnection.put(PASSWORD,"ale20142");
    confConnection.put(SHOW_ALL_DATABASE,"false");
    confConnection.put(DATABASE,"TIESSEFIL");
    confConnection.put(NAME,"local");
    connections.add(confConnection);


    /* Add new connection
    confConnection = new HashMap<String, String>();
    confConnection.put(HOST, "1.1.1.1");
    confConnection.put(USER,"");
    confConnection.put(PASSWORD,"");
    confConnection.put(SHOW_ALL_DATABASE,"false");
    confConnection.put(DATABASE,"");
    confConnection.put(NAME,"local");
    connections.add(confConnection);
    */


      out.write('\n');
      out.write('\n');
      out.write('\n');
      out.write('\n');
      out.write('\n');
      out.write('\n');
      out.write('\n');
      out.write('\n');
      out.write('\n');



    try {

        Logger log = Logger.getLogger("report.jsp");
        //String idUtente = session.getAttribute("IDUTENTE").toString();
        // Prendo elenco menuItems
        // Prendo i parametri
        //doGet(request);

    //    request.setAttribute("connections",  confConnection);
        JSONArray mainMenu = new JSONArray();

        Iterator conn = connections.iterator();

        while (conn.hasNext()){
            HashMap<String, String> con = (HashMap) conn.next();
            log.debug(" Creating menu databases loop host:  " + con.get(HOST));
            mainMenu = getConnectionDBMenu(mainMenu,
                    con.get(HOST),
                    con.get(DATABASE),
                    con.get(USER),
                    con.get(PASSWORD),
                    con.get(SHOW_ALL_DATABASE)
            );
            log.debug(" menu databases loop end");
            // Stampo l'errore di accesso negato
            if (mainMenu.isEmpty()) {
                mainMenu.add(getMenuItem("Non sono presenti grafici", null, "disableMe"));
            }
        }


        // E stampiamo sto benedetto JSON

        out.print(mainMenu);
        log.debug("output printed");
    } catch (ConnectionException ex) {
        log.error(ex);
    }

      out.write('\n');
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null && out.getBufferSize() != 0)
          try { out.clearBuffer(); } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}
